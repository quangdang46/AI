# -*- coding: utf-8 -*-
"""lab01-UninformedSearch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LpRW0dVgPkZMRtqoImUUDrcj-FoNN184

Course: **Introduction to Artificial Intelligence** \
Lecturer: **Nguyen Thanh An** \
Lab 01: **Uninformed Search**

Students refer to pseudo codes of BFS, DFS, UCS, DLS, and IDS in [this link](https://drive.google.com/file/d/1q2LtrRCfemfiqyhfxNMcVJ3alvLh_pdV/view?usp=share_link) to implement the corresponding classes in TODO 1 - 5. \
Students can add supporting attributes and methods to the five classes as needed.

# Libraries
"""

import os
import heapq

"""# Graph class"""

# Directed, weighted graphs
class Graph:
  def __init__(self):
    self.AL = dict() # adjacency list
    self.V = 0
    self.E = 0

  def __str__(self):
    res = 'V: %d, E: %d\n'%(self.V, self.E)
    for u, neighbors in self.AL.items():
      line = '%d: %s\n'%(u, str(neighbors))
      res += line
    return res

  def print(self):
    print(str(self))

  def load_from_file(self, filename):
    '''
        Example input file:
            V E
            u v w
            u v w
            u v w
            ...

        # input.txt
        7 9
        0 1 5
        0 2 6
        1 3 12
        1 4 9
        2 5 5
        3 5 8
        3 6 7
        4 6 4
    '''
    if os.path.exists(filename):
      with open(filename) as g:
        self.V, self.E = [int(it) for it in g.readline().split()]
        for line in g:
          u, v, w = [int(it) for it in line.strip().split()]
          if u not in self.AL:
            self.AL[u] = []
          self.AL[u].append((v, w))

g = Graph()
g.load_from_file('input.txt')
g.print()

"""# Search Strategies"""

class SearchStrategy:
  def search(self, g: Graph, src: int, dst: int) -> tuple:
    expanded = [] # list of expanded vertices in the traversal order
    path = [] # path from src to dst
    return expanded, path

class BFS(SearchStrategy):
  def search(self, g: Graph, src: int, dst: int) -> tuple:
    expanded = [] # list of expanded vertices in the traversal order
    path = [] # path from src to dst
    # TODO 1
    if src == dst:
      return expanded, path
    
    visited = [False for _ in range(g.V)]
    queue = [src]
    visited[src] = True
    while queue:
      u = queue.pop(0)
      expanded.append(u)
      if u == dst:
        break
      for v, _ in g.AL.get(u, []):
        if not visited[v]:
          queue.append(v)
          visited[v] = True

    return expanded, path


class DFS(SearchStrategy):
  def search(self, g: Graph, src: int, dst: int) -> tuple:
    expanded = [] # list of expanded vertices in the traversal order
    path = [] # path from src to dst
    stack = [src]
    parent = {src: None}

    while stack:
      u = stack.pop()
      expanded.append(u)

      if u == dst:
        break

      for v, _ in g.AL.get(u, []):
        if v not in parent:
          parent[v] = u
          stack.append(v)

    if dst in parent:
      v = dst
      while v is not None:
        path.append(v)
        v = parent[v]

    path.reverse()
    return expanded, path

class UCS(SearchStrategy):
  def search(self, g: Graph, src: int, dst: int) -> tuple:
    expanded = [] # list of expanded vertices in the traversal order
    path = [] # path from src to dst

    # TODO 3
    heap = [(0, src)] 
    parent = {src: None} 
    cost = {src: 0}

    while heap:
      u_cost, u = heapq.heappop(heap)
      expanded.append(u)

      if u == dst:
        break

      for v, w in g.AL.get(u, []):
        if v not in cost or cost[u] + w < cost[v]:
          cost[v] = cost[u] + w
          parent[v] = u
          heapq.heappush(heap, (cost[v], v))

    if dst in parent:
      v = dst
      while v is not None:
        path.append(v)
        v = parent[v]

    path.reverse()
    
    return expanded, path

class DLS(SearchStrategy):
  def __init__(self, LIM: int):
    self.LIM = LIM
  
  def search(self, g: Graph, src: int, dst: int) -> tuple:
    expanded = [] # list of expanded vertices in the traversal order
    path = [] # path from src to dst

    # TODO 4
    stack = [(0, src)]

    while stack:
      depth, u = stack.pop()
      expanded.append(u)

      if depth == self.LIM:
        continue

      if u == dst:
        break

      for v, _ in g.AL.get(u, []):
        stack.append((depth + 1, v))
    return expanded, path

class IDS(SearchStrategy):
  def __init__(self, MAX_LIM: int):
    self.MAX_LIM = MAX_LIM
  
  def search(self, g: Graph, src: int, dst: int) -> tuple:
    expanded = [] # list of expanded vertices in the traversal order
    path = [] # path from src to dst

    # TODO 5
    for lim in range(self.MAX_LIM):
      dls = DLS(lim)
      expanded, path = dls.search(g, src, dst)
      if  not path:
        return expanded, []
    return expanded, path

"""# Evaluation"""

bfs = BFS()
dfs = DFS()
ucs = UCS()
dls = DLS(LIM=3)
ids = IDS(MAX_LIM=5)

for stg in [bfs, dfs, ucs, dls, ids]:
  print(stg)
  expanded, path = stg.search(g, 0, g.V-1)
  print(expanded)
  print(path)

"""# Submission Notice


*   Maintain all cell outputs
*   Download and rename the notebook as **lab01_\<Student ID\>.ipynb**
*   Submit by the deadline

"""